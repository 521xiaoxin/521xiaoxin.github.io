import{aw as s,q as i,p as a,aS as n}from"./chunks/framework.D2i5q5tO.js";const F=JSON.parse('{"title":"更多宝藏","description":"","frontmatter":{},"headers":[],"relativePath":"算法/系列文章/一分钟学算法-递归-斐波那契数列递归解法及优化.md","filePath":"算法/系列文章/一分钟学算法-递归-斐波那契数列递归解法及优化.md","lastUpdated":1718006042000}'),p={name:"算法/系列文章/一分钟学算法-递归-斐波那契数列递归解法及优化.md"},h=n(`<p><img src="https://img-blog.csdnimg.cn/8537a58e01644fe999eade1e67f50072.png" alt="请添加图片描述"></p><p>一分钟学一个算法题目。</p><p>今天我们要学习的是用递归算法求解斐波那契数列。</p><p>视频教程链接：<a href="https://www.bilibili.com/video/BV1Wu4y1i7JJ/" target="_blank" rel="noreferrer">https://www.bilibili.com/video/BV1Wu4y1i7JJ/</a></p><p>首先我们要知道什么是斐波那契数列。</p><p>斐波那契数列，又称黄金分割数列，是一个经典的数学数列，其特点是第一项，第二项为1，后面每个数字都是前两个数字之和。推导过程如视频所示，非常非常简单。</p><p>知道了斐波那契数列的定义后，我们将其代入到递归问题的分析当中。</p><p>首先确定边界条件，就是第一项和第二项为1，接着确定递归关系，后一项等于前两项的和。确定了上面这些关系，我们就可以写出下面的代码了。</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fib</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x):</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 边界条件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> or</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 递归关系</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fib(x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fib(x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fib(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fib(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fib(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fib(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fib(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fib(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div><p>没错，去掉注释和空行后只有三行代码，简洁精炼是递归问题的共性，你学习过肯定深有体会。下面我们稍微解读下代码，这是一个求解斐波那契数列第n项数字的函数，函数名为fib，接受一个参数n。</p><p>如果n等于1或者2，那么就返回1，否则就返回fib(n-2)与fib(n-1)的和，怎么样，脑子转过来弯了吗？没错，就是这么简单。我们来尝试运行使用函数检验一下正确性，发现都输出了正确结果。</p><p>但是这个函数还有很大的优化空间，在哪里呢？没错，递归算法让我们使用简洁的代码解决复杂的问题。但他的时间复杂度很高，一不小心没做好边界与转换关系判断就会导致无限循环或者栈溢出。</p><p>我们以此题为例，假如我们要求解斐波那契数列的第一百项数字，那麽我们会得到这张调用关系图，同一项会被重复计算非常非常多次。所以你运行此函数可能会导致很长时间都计算不出结果。</p><p>那么，我们该如何优化呢？ 我们该如何避免重复计算某一项的值呢？</p><p>我们可以在计算出每一项的时候，把计算结果存到一个字典里。这样我们在每次计算前先去字典中寻找这一项，如果有值，那么直接拿出来使用，如果没有，再计算它。</p><p>这样的话我们就可以保证每一项仅被计算一次。运行时间也将会大大缩短。按照以上思路我们对代码进行如下变化。</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fib</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n):</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 边界条件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> or</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> hash</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.get(n,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> hash</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.get(n)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 递归关系</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ans</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fib(n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fib(n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    hash</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[ans]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ans</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ans</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">hash</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{}</span></span></code></pre></div><p>在代码中我们增加了以下变化： 每次计算某一项时先去集合中查询，如果已经计算过，那么直接返回值，如果没有，则计算，并且在返回值之前先在集合中记录一下。</p><p>这样代码的算法复杂度已经优化了很多了，没有优化版本求解第70项都非常费力，现在优化后已经可以轻松算出第100项了。但要想算出第一百项还是需要很久时间。</p><p>因为其中还存在大量的分支判断。</p><p>而且此解法还远远不是最优解法，关注up主，我们下集就来讲讲更快的方法。</p><h1 id="更多宝藏" tabindex="-1">更多宝藏 <a class="header-anchor" href="#更多宝藏" aria-label="Permalink to &quot;更多宝藏&quot;">​</a></h1><p>🍇🍉🍊🍏🍋🍅🥝🥥🫒🫕🥗</p><p>公众号名称😮：Python斗罗</p><p>博客文章看这里🤭： <a href="https://blog.csdn.net/weixin_62650212" target="_blank" rel="noreferrer">https://blog.csdn.net/weixin_62650212</a></p><p>视频推送看这里🤤： <a href="https://space.bilibili.com/1909782963" target="_blank" rel="noreferrer">https://space.bilibili.com/1909782963</a></p>`,26),k=[h];function l(t,e,r,E,d,g){return a(),i("div",null,k)}const c=s(p,[["render",l]]);export{F as __pageData,c as default};
