import{_ as s,c as i,o as a,aR as t}from"./chunks/framework.DinLaFdC.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"前端/系列文章/vitepress环境差异记录.md","filePath":"前端/系列文章/vitepress环境差异记录.md","lastUpdated":1713272161000}'),e={name:"前端/系列文章/vitepress环境差异记录.md"},n=t(`<p>不是专业的，轻点喷，希望大佬不吝赐教。</p><p>第一次遇到不同环境运行导致的运行差异。<br> 事情的起因是这样的，今天下午给自己的使用vitepress搭建的博客添加了鼠标样式并且成功上线，但是在本地再次运行的时候发现鼠标样式没有了。<br> 但是代码没有任何改动，打包之后preview也是正常的，上线也是正常的，本地环境跑了多次却不显示鼠标的样式。<br> 然后我就开始了调试，首先确认了问题的存在：通过在代码中加入 console.log 语句调试后，我发现DOMContentLoaded事件在本地环境不触发，最后询问gpt之后确认是因为在本地环境中页面加载速度极快，DOMContentLoaded事件在 JavaScript 代码执行之前就已经触发，所以我写的事件监听自然就无效了。<br> 为了确保 <code>init</code> 函数在所有环境中都能正确执行，引入了一个检查 <code>document.readyState</code> 的步骤。如果页面在脚本执行时已经完成加载（<code>document.readyState</code> 不是 <code>&quot;loading&quot;</code>），则直接调用 <code>init</code> 函数。这确保了无论 <code>DOMContentLoaded</code> 是否已经触发，初始化逻辑都能被执行。<br> 通过简单的 <code>document.readyState</code> 检查，可以有效解决因页面加载速度差异导致的事件监听问题。这个技术不仅适用于 <code>DOMContentLoaded</code> 事件，也可以用于处理其他依赖于特定加载状态的脚本执行逻辑。<br> 希望能够给大家一定的借鉴，如果有帮到你，希望可以给出免费的三连。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/38536969/1713271373783-6dfbad1f-34f8-48ea-a163-93402ad6bba3.png#averageHue=%23fcfcfc&amp;clientId=ub283c129-0e75-4&amp;from=paste&amp;height=582&amp;id=ud7daf30b&amp;originHeight=727&amp;originWidth=1409&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=43044&amp;status=done&amp;style=none&amp;taskId=u1ff8ce63-2946-45b1-8e85-606b74c231f&amp;title=&amp;width=1127.2" alt="image.png"></p><h2 id="我直接执行就可以正常显示-那么添加事件监听是不是有点没必要" tabindex="-1">我直接执行就可以正常显示，那么添加事件监听是不是有点没必要 <a class="header-anchor" href="#我直接执行就可以正常显示-那么添加事件监听是不是有点没必要" aria-label="Permalink to &quot;我直接执行就可以正常显示，那么添加事件监听是不是有点没必要&quot;">​</a></h2><p>如果你发现在直接执行初始化函数时可以正常显示，并且没有遇到任何问题，那么在某些情况下确实可以省略添加事件监听器的步骤，尤其是当你的脚本确保只在全部元素都加载完成后才运行时。然而，这种方法是否适用，需要根据具体情况来判断。以下是一些考虑因素：</p><h3 id="_1-页面内容依赖" tabindex="-1">1. <strong>页面内容依赖</strong> <a class="header-anchor" href="#_1-页面内容依赖" aria-label="Permalink to &quot;1. **页面内容依赖**&quot;">​</a></h3><p>如果你的 JavaScript 初始化函数依赖于 DOM 元素（比如你需要绑定事件到特定元素，或者修改 DOM 结构），直接执行可能会在 DOM 完全加载之前运行，从而导致错误。<code>DOMContentLoaded</code> 事件确保了所有的 HTML 都已经被完全加载和解析，但不包括样式表、图片和子框架。所以使用 <code>DOMContentLoaded</code> 监听器可以保证 DOM 完全可用。</p><h3 id="_2-脚本放置位置" tabindex="-1">2. <strong>脚本放置位置</strong> <a class="header-anchor" href="#_2-脚本放置位置" aria-label="Permalink to &quot;2. **脚本放置位置**&quot;">​</a></h3><ul><li>如果你的 <code>&lt;script&gt;</code> 标签位于 <code>&lt;/body&gt;</code> 标签之前（页面底部），那么大多数情况下，当脚本执行时，DOM 已经解析完成，你可以直接调用初始化函数。</li><li>如果 <code>&lt;script&gt;</code> 标签位于 <code>&lt;head&gt;</code> 中或者在多个 DOM 元素之前，那么在没有监听 <code>DOMContentLoaded</code> 的情况下直接执行可能会因为 DOM 尚未加载完全而失败。</li></ul><h3 id="_3-执行时机的可控性" tabindex="-1">3. <strong>执行时机的可控性</strong> <a class="header-anchor" href="#_3-执行时机的可控性" aria-label="Permalink to &quot;3. **执行时机的可控性**&quot;">​</a></h3><p>使用 <code>DOMContentLoaded</code> 监听器的好处是提供了一致的执行时机，确保所有的前置条件（DOM 加载和解析完成）都已满足。这种方法提高了代码的健壮性和可移植性，使其在不同环境和条件下表现一致。</p><h3 id="_4-维护和可读性" tabindex="-1">4. <strong>维护和可读性</strong> <a class="header-anchor" href="#_4-维护和可读性" aria-label="Permalink to &quot;4. **维护和可读性**&quot;">​</a></h3><p>即使在脚本执行时 DOM 总是可用的情况下省略 <code>DOMContentLoaded</code>，也可能会对未来的维护或其他开发者阅读你的代码造成困扰。他们可能不清楚为何省略了这一步，或者在将来修改页面结构后可能不了解将脚本移动到 <code>&lt;head&gt;</code> 中的影响。</p><h3 id="结论" tabindex="-1">结论 <a class="header-anchor" href="#结论" aria-label="Permalink to &quot;结论&quot;">​</a></h3><p>在大多数情况下，如果不确定或者你的脚本有可能被移动到不同的位置，最好是保留对 <code>DOMContentLoaded</code> 的监听，以确保代码的稳定性和可靠性。如果你确信脚本总是在所有相关的 DOM 元素加载之后执行（如放置在文档的最后），并且你愿意接受这种代码在未来可能需要调整的风险，那么直接执行也是可行的。这取决于你的项目需求、团队约定以及你对代码执行环境的控制程度。</p><h2 id="我的引入js写在head里-获取body向里面插入内容是否会报错" tabindex="-1">我的引入js写在head里，获取body向里面插入内容是否会报错 <a class="header-anchor" href="#我的引入js写在head里-获取body向里面插入内容是否会报错" aria-label="Permalink to &quot;我的引入js写在head里，获取body向里面插入内容是否会报错&quot;">​</a></h2><p>如果你的 JavaScript 代码是在 <code>&lt;head&gt;</code> 部分引入，并且该代码尝试直接操作或向 <code>&lt;body&gt;</code> 元素添加内容，你可能会遇到问题，因为当脚本执行时，页面的 <code>&lt;body&gt;</code> 部分可能还未被浏览器解析和加载。这通常会导致脚本无法找到 <code>&lt;body&gt;</code> 元素或尝试操作的其他 DOM 元素，从而引发错误或导致脚本无效。</p><h3 id="问题示例" tabindex="-1">问题示例 <a class="header-anchor" href="#问题示例" aria-label="Permalink to &quot;问题示例&quot;">​</a></h3><p>假设你的 HTML 和 JavaScript 如下所示：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;!</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">DOCTYPE</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> html</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">html</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Test Page&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;script.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    &lt;!-- 页面内容 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">html</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>在 <code>script.js</code> 中，你可能有如下代码：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span></code></pre></div><p>在这种情况下，当 <code>script.js</code> 执行时，<code>&lt;body&gt;</code> 元素可能还没有被完全加载，因此 <code>document.body</code> 可能是 <code>null</code>，导致调用 <code>appendChild</code> 方法时抛出错误。</p><h3 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to &quot;解决方案&quot;">​</a></h3><p>为了确保你的脚本可以安全地访问和操作 <code>&lt;body&gt;</code> 或其它 DOM 元素，你可以采取以下几种常见的策略：</p><ol><li><strong>将脚本移动到 <strong><code>**&lt;body&gt;**</code></strong> 标签的底部</strong>：<br>这是最简单的解决方案，确保当脚本执行时，所有的 DOM 元素都已经加载完成。</li></ol><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    &lt;!-- 页面内容 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;script.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><ol start="2"><li><strong>使用 <strong><code>**DOMContentLoaded**</code></strong> 事件</strong>：<br>如果你需要或更愿意将脚本保留在 <code>&lt;head&gt;</code> 中，可以通过监听 <code>DOMContentLoaded</code> 事件来确保 DOM 完全加载和解析完成后再运行你的脚本。</li></ol><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;DOMContentLoaded&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><ol start="3"><li><strong>异步加载 JavaScript</strong>：<br>将脚本标记为异步 (<code>async</code>) 或延迟 (<code>defer</code>)。这两种方法都能确保脚本在文档解析完成后再执行，但它们的具体行为略有不同： <ul><li>使用 <code>async</code>：脚本会在它下载完成后尽快执行，但不会等待其他脚本或样式表，可能在 <code>DOMContentLoaded</code> 之前或之后。</li><li>使用 <code>defer</code>：脚本会在整个文档解析完成后、在 <code>DOMContentLoaded</code> 事件前执行。</li></ul></li></ol><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;script.js&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h3 id="结论-1" tabindex="-1">结论 <a class="header-anchor" href="#结论-1" aria-label="Permalink to &quot;结论&quot;">​</a></h3><p>最保险的做法是使用 <code>DOMContentLoaded</code> 监听器或将脚本放置在 <code>&lt;body&gt;</code> 的末尾，这样可以保证在执行脚本时 DOM 完全可用。选择哪种方法取决于你的具体需求和页面加载性能的考量。</p>`,33),l=[n];function h(d,p,o,k,r,c){return a(),i("div",null,l)}const y=s(e,[["render",h]]);export{g as __pageData,y as default};
