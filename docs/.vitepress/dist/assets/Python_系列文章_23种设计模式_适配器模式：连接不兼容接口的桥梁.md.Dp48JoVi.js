import{_ as s,c as a,o as i,aR as t}from"./chunks/framework.DoYNU3c7.js";const u=JSON.parse('{"title":"适配器模式：连接不兼容接口的桥梁","description":"","frontmatter":{},"headers":[],"relativePath":"Python/系列文章/23种设计模式/适配器模式：连接不兼容接口的桥梁.md","filePath":"Python/系列文章/23种设计模式/适配器模式：连接不兼容接口的桥梁.md","lastUpdated":null}'),n={name:"Python/系列文章/23种设计模式/适配器模式：连接不兼容接口的桥梁.md"},e=t(`<h1 id="适配器模式-连接不兼容接口的桥梁" tabindex="-1">适配器模式：连接不兼容接口的桥梁 <a class="header-anchor" href="#适配器模式-连接不兼容接口的桥梁" aria-label="Permalink to &quot;适配器模式：连接不兼容接口的桥梁&quot;">​</a></h1><p>在软件开发中，适配器模式是一种结构型设计模式，它允许不兼容的接口之间进行交互，从而使它们能够一起工作。这个模式经常用于系统升级或集成第三方库的时候，当现有的代码无法直接使用新系统或库提供的接口时，适配器可以在不修改现有代码的情况下实现功能的整合。本文将详细介绍适配器模式的定义、实现、应用场景以及优缺点。</p><p><img src="https://img-blog.csdnimg.cn/direct/11733f481f2c4cbe9781ad7b1f36e2cd.webp#pic_center" alt="在这里插入图片描述"></p><h2 id="_1-适配器模式的定义" tabindex="-1">1. 适配器模式的定义 <a class="header-anchor" href="#_1-适配器模式的定义" aria-label="Permalink to &quot;1. 适配器模式的定义&quot;">​</a></h2><p>适配器模式（Adapter Pattern）也被称为包装器（Wrapper），这种模式作为两个不兼容的接口之间的桥梁，将一个类的接口转换成客户期望的另一个接口。适配器模式让那些由于接口不兼容而不能一起工作的类可以一起工作。</p><h2 id="_2-实现适配器模式" tabindex="-1">2. 实现适配器模式 <a class="header-anchor" href="#_2-实现适配器模式" aria-label="Permalink to &quot;2. 实现适配器模式&quot;">​</a></h2><p>适配器模式主要有两种实现方式：类适配器和对象适配器。类适配器使用多重继承对一个类的接口进行转换，而对象适配器则使用组合来实现接口的适配。以下是使用对象适配器方式的示例：</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;&quot;&quot;这是客户所期望的接口。&quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> request</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Target: The default target&#39;s behavior.&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Adaptee</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;&quot;&quot;这是需要适配的类。&quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> specific_request</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;.eetpadA eht fo roivaheb laicepS&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Adapter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Adaptee</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">):</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;&quot;&quot;适配器通过在内部包装一个 Adaptee 对象，将接口从 Adaptee 转换为 Target。&quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> request</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Adapter: (TRANSLATED) </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">{self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.specific_request()[::</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">}</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 使用适配器实现</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">target </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Adapter()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target.request())  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 输出: Adapter: (TRANSLATED) Special behavior of the Adaptee.</span></span></code></pre></div><h2 id="_3-适配器模式的应用实例" tabindex="-1">3. 适配器模式的应用实例 <a class="header-anchor" href="#_3-适配器模式的应用实例" aria-label="Permalink to &quot;3. 适配器模式的应用实例&quot;">​</a></h2><p>适配器模式在软件开发中有许多实际应用，例如：</p><ul><li><strong>集成第三方库</strong>：当第三方库的接口与现有系统的接口不匹配时，可以使用适配器。</li><li><strong>系统升级</strong>：在系统升级过程中保持向后兼容性。</li><li><strong>设备驱动</strong>：为不同的设备提供统一的接口。</li></ul><h2 id="_4-适配器模式的优点和缺点" tabindex="-1">4. 适配器模式的优点和缺点 <a class="header-anchor" href="#_4-适配器模式的优点和缺点" aria-label="Permalink to &quot;4. 适配器模式的优点和缺点&quot;">​</a></h2><h3 id="优点" tabindex="-1">优点： <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点：&quot;">​</a></h3><ul><li><strong>增强了类的透明性和复用</strong>：现有的类可以在不修改其源代码的情况下复用。</li><li><strong>灵活性和扩展性增强</strong>：可以在不修改现有代码的情况下引入新的适配器。</li></ul><h3 id="缺点" tabindex="-1">缺点： <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点：&quot;">​</a></h3><ul><li><strong>复杂性增加</strong>：系统中可能会增加许多小对象，如适配器，使得系统整体设计更加复杂。</li></ul><h2 id="_5-总结" tabindex="-1">5. 总结 <a class="header-anchor" href="#_5-总结" aria-label="Permalink to &quot;5. 总结&quot;">​</a></h2><p>适配器模式提供了一种有效的方式来解决接口不兼容问题，使得原本由于接口不匹配而不能一起工作的类可以协同工作。正确应用此模式可以显著提高现有代码的复用性和系统的灵活性。希望本文能帮助您理解适配器模式的核心概念，并在您的项目中有效地应用这一模式。</p>`,18),l=[e];function h(p,r,k,d,o,c){return i(),a("div",null,l)}const E=s(n,[["render",h]]);export{u as __pageData,E as default};
